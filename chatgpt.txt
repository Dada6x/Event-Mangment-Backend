Server

// server.js
const express = require("express");
const mongoose = require("mongoose");
const cors = require("cors");
// require("dotenv").config();
const authRoute = require("./routes/auth_routes");
const userRoute = require("./routes/user_routes");
const eventRoute = require("./routes/event_routes");
const adminRoute = require("./routes/admin_routes");
const app = express();
const swaggerUi = require("swagger-ui-express");
const swaggerDocument = require("./swagger.json");

//! ====== keep only this, with the limit ======
app.use(express.json({ limit: "10mb" }));
app.use(express.urlencoded({ extended: true, limit: "10mb" }));

//! allow mobile device too while testing
app.use(cors({ origin: "*" }));

//! ====== MongoDB Connect ======
mongoose
  .connect("mongodb://127.0.0.1:27017/Event_mangment")
  .then(() => console.log("Mongo connected"))
  .catch((err) => console.error(err));

app.get("/", (req, res) => {
  res.send("API running");
});
//! ====== SwaggerUI ======
app.use("/api-docs", swaggerUi.serve, swaggerUi.setup(swaggerDocument));
app.get("/", (req, res) => {
  res.send("API running");
});
//? swagger_URL:  http://localhost:3000/api-docs/

//! ====== Routes ======
app.use("/api", userRoute);
app.use("/api/auth", authRoute);
app.use("/api/events", eventRoute);
app.use("/api/admin", adminRoute);
app.use("/request",requestRoute)

//! ====== Start server ======
app.listen(3000, () => {
  console.log("Server running on port 3000");
});

routes 
// routes/admin_routes.js
const express = require("express");
const {
  getAllUsers,
  getAllEvents,
  getAllEventRequests,
  approveEventRequest,
  rejectEventRequest,
} = require("../controller/admin_controller");
const { protect, authorize } = require("../middlewares/middlewares"); // you add isAdmin

const adminRoute = express.Router();
//? ====== Only Admin is able to use this  ======

adminRoute.use(protect, authorize("admin"));
//$ ====== Get all Users ======
adminRoute.get("/users", getAllUsers);
//$ ====== Get ALl Accepted Events ======
adminRoute.get("/events", getAllEvents);
//$ ====== Get All Requests  ======
adminRoute.get("/requests", getAllEventRequests);
//$ ====== Approve an Request ======
adminRoute.patch("/requests/:id/approve", approveEventRequest);
//$ ====== Reject an Request ======
adminRoute.patch("/requests/:id/reject", rejectEventRequest);

module.exports = adminRoute;
const express = require("express");
const { login, signup } = require("../controller/auth_controller");
const authRoute = express.Router();

//$ ====== Login ======
authRoute.post("/login", login);
//$ ====== SignUp ======
authRoute.post("/signup", signup);

module.exports = authRoute;
// routes/event_routes.js
const express = require("express");
const {
  addEventRequest,
  EditEventRequestById,
  cancelEventRequestById,
  getEventRequestDetails,
  getMyEventRequests,
} = require("../controller/event_controller");
const { protect } = require("../middlewares/middlewares");

const eventRoute = express.Router();
//$ ====== Add new Request  ======
eventRoute.post("/", protect, addEventRequest);
//$ ====== cancel Request ======
eventRoute.delete("/:requestId", protect, cancelEventRequestById);
//! ====== Edit Request ======
eventRoute.patch("/", protect, EditEventRequestById);
//$ ====== Get all My Requests ======
eventRoute.get("/", protect, getMyEventRequests);
//$ ====== Get Request DetailsBy ID ======
eventRoute.get("/:id", protect, getEventRequestDetails);

module.exports = eventRoute;
// routes/user_routes.js
const express = require("express");
const {
  me,
  getMyEvents,
} = require("../controller/user_controller");
const { protect, } = require("../middlewares/middlewares");

const userRoute = express.Router();
//$ ====== Get my details (Profile) ======
userRoute.get("/me", protect, me);
//$ ====== Get All My Events (accepted ones) ======
userRoute.get("/my-events", protect, getMyEvents);


module.exports = userRoute;


Models
// model/event_model.js
const mongoose = require("mongoose");

const VenueSchema = new mongoose.Schema(
  {
    image: { type: String, required: true },
    name: { type: String, required: true, trim: true },
    address: { type: String, required: true },
    cost: { type: Number, required: true },
    type: { type: String, enum: ["lounge", "theatre"], required: true },
  },
  { _id: false }
);

const EventSchema = new mongoose.Schema(
  {
    //! the User
    organizerId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },

    //! Event Name
    eventName: {
      type: String,
      required: true,
      trim: true,
    },

    eventDescription: { type: String, default: "" },

    occasionType: {
      type: String,
      enum: ["public", "private"],
      required: true,
    },

    //! DATE & TIME
    eventDate: { type: String, required: true },
    eventTime: { type: String, required: true },

    //! PRICE
    price: { type: Number, required: true },

    //! INVITATION LINK
    invitationLink: { type: String, default: "" },

    //! Max Attendance
    maxAttendance: { type: Number, required: true },

    //! Event Type
    eventType: {
      type: String,
      enum: [
        "wedding",
        "engagement",
        "graduation",
        "familyEvent",
        "photoSession",
        "musicalParty",
        "festival",
        "conference",
        "play",
        "custom",
      ],
      required: true,
    },

    //! LOCATION TYPE
    locationType: {
      type: String,
      enum: ["home", "lounge", "theatre"],
      required: true,
    },

    //! Used ONLY when locationType === "home"
    homeAddress: { type: String },

    //! Embedded venue data when NOT home
    venue: VenueSchema, // EMBEDDED â€” NO collection anymore

    //! SERVICES
    services: {
      hospitality: {
        enabled: { type: Boolean, default: false },
        cost: { type: Number, default: 0 },
        drinks: { type: Boolean, default: false },
        food: { type: Boolean, default: false },
        cake: { type: Boolean, default: false },
        icecream: { type: Boolean, default: false },
      },
      camera: {
        enabled: { type: Boolean, default: false },
        cost: { type: Number, default: 0 },
      },
      decoration: {
        enabled: { type: Boolean, default: false },
        cost: { type: Number, default: 0 },
      },
      limousine: {
        enabled: { type: Boolean, default: false },
        cost: { type: Number, default: 0 },
      },
      musicalBand: {
        enabled: { type: Boolean, default: false },
        cost: { type: Number, default: 0 },
      },
    },
  },
  { timestamps: true }
);

module.exports = mongoose.model("Event", EventSchema);
const mongoose = require("mongoose");
const Event = require("./event_model");

const RequestEventSchema = new mongoose.Schema(
  {
    requestType: {
      type: String,
      enum: ["create", "edit", "cancel"],
      required: true,
    },
    status: {
      type: String,
      enum: ["pending", "approved", "rejected"],
      default: "pending",
    },
    requestedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    eventId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Event",
    },
    event: {
      type: Event.schema,
      required: true,
    },
  },
  { timestamps: true, collection: "request_Events" }
);

module.exports = mongoose.model("RequestEvent", RequestEventSchema);
// model/user_model.js
const mongoose = require("mongoose");

const userSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    email: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
    },
    password: {
      type: String,
      required: true,
      minlength: 6,
    },
    role: {
      type: String,
      enum: ["user", "admin"],
      default: "user",
    },
    avatar: {
      type: String, 
      default: null, 
    },
  },
  { timestamps: true }
);

module.exports = mongoose.model("User", userSchema, "Users");


Controllers
const User = require("../model/user_model");
const Event = require("../model/event_model");
const RequestEvent = require("../model/request_model");

//$ ====== get ALl users (Admin) ======
exports.getAllUsers = async (req, res, next) => {
  try {
    const users = await User.find().select("-password"); // don't expose passwords
    return res.status(200).json({
      success: true,
      count: users.length,
      data: users,
    });
  } catch (err) {
    next(err);
  }
};
//$ ====== Get All Events (Admin) ======
exports.getAllEvents = async (req, res, next) => {
  try {
    const events = await Event.find().populate("organizerId", "name email");

    return res.status(200).json({
      success: true,
      count: events.length,
      data: events,
    });
  } catch (err) {
    next(err);
  }
};
//$ ====== Get All  Requests ======
exports.getAllEventRequests = async (req, res, next) => {
  try {
    const requests = await RequestEvent.find()
      .populate("requestedBy", "name email")
      .populate("eventId")
      .sort({ createdAt: -1 });

    return res.status(200).json({
      success: true,
      count: requests.length,
      data: requests,
    });
  } catch (err) {
    next(err);
  }
};
//$ ====== Approve Event By ID ======
exports.approveEventRequest = async (req, res, next) => {
  try {
    const { id } = req.params; // RequestEvent _id
    const request = await RequestEvent.findById(id);

    if (!request) {
      return res.status(404).json({
        success: false,
        message: "Request not found",
      });
    }

    if (request.status !== "pending") {
      return res.status(400).json({
        success: false,
        message: `Request already ${request.status}`,
      });
    }

    let resultEvent = null;

    // ---------- CREATE ----------
    if (request.requestType === "create") {
      // convert snapshot to plain new event
      let eventData = request.event.toObject
        ? request.event.toObject()
        : request.event;

      delete eventData._id;
      delete eventData.createdAt;
      delete eventData.updatedAt;

      resultEvent = await Event.create(eventData);

      // delete request after success
      await RequestEvent.findByIdAndDelete(id);
    }

    // ---------- EDIT ----------
    else if (request.requestType === "edit") {
      if (!request.eventId) {
        return res.status(400).json({
          success: false,
          message: "Edit request missing eventId",
        });
      }

      let updates = request.event.toObject
        ? request.event.toObject()
        : request.event;

      delete updates._id;
      delete updates.createdAt;
      delete updates.updatedAt;

      resultEvent = await Event.findByIdAndUpdate(request.eventId, updates, {
        new: true,
        runValidators: true,
      });

      if (!resultEvent) {
        return res.status(404).json({
          success: false,
          message: "Original event not found",
        });
      }

      // delete request after success
      await RequestEvent.findByIdAndDelete(id);
    }

    // ---------- CANCEL ----------
    else if (request.requestType === "cancel") {
      if (!request.eventId) {
        return res.status(400).json({
          success: false,
          message: "Cancel request missing eventId",
        });
      }

      await Event.findByIdAndDelete(request.eventId);

      // delete request after success
      await RequestEvent.findByIdAndDelete(id);
    }

    // ---------- UNKNOWN ----------
    else {
      return res.status(400).json({
        success: false,
        message: `Unknown requestType: ${request.requestType}`,
      });
    }

    return res.status(200).json({
      success: true,
      message: "Request approved and removed from queue",
      data: {
        event: resultEvent,
      },
    });
  } catch (err) {
    next(err);
  }
};
//$ ====== Reject Event By ID ======
exports.rejectEventRequest = async (req, res, next) => {
  try {
    const { id } = req.params;

    const request = await RequestEvent.findById(id);
    if (!request) {
      return res.status(404).json({
        success: false,
        message: "Request not found",
      });
    }

    if (request.status !== "pending") {
      return res.status(400).json({
        success: false,
        message: `Request already ${request.status}`,
      });
    }

    request.status = "rejected";
    await request.save();

    return res.status(200).json({
      success: true,
      message: "Request rejected successfully",
      data: request,
    });
  } catch (err) {
    next(err);
  }
};
// controller/auth_controller.js
const User = require("../model/user_model");
const bcrypt = require("bcryptjs");
const { createToken } = require("../utils/jwt_helper");

//$ ====== Login  ======
exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "Invalid credentials" });

    const match = await bcrypt.compare(password, user.password);
    if (!match) return res.status(400).json({ message: "Invalid credentials" });

    const token = createToken(user);

    res.json({
      message: "Logged in",
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        role: user.role,
        avatar: user.avatar,
      },
      token,
    });
  } catch (err) {
    console.error("Login error:", err);
    res.status(500).json({ message: "Server error" });
  }
};
//$ ====== Signup  ======
exports.signup = async (req, res) => {
  try {
    const { name, email, password, role, avatar } = req.body;

    if (!name || !email || !password) {
      return res
        .status(400)
        .json({ message: "name, email, password are required" });
    }

    //@ 1) Check if email exists in DB
    const exists = await User.findOne({ email });
    if (exists) {
      return res.status(400).json({ message: "Email already exists" });
    }

    //@ 2) Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    //@ 3) Create user
    const user = await User.create({
      name,
      email,
      password: hashedPassword,
      role: role || "user",
      avatar: avatar || null,
    });

    //@ 4) Create token
    const token = createToken(user);

    res.status(201).json({
      message: "User created",
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        role: user.role,
        avatar: user.avatar,
      },
      token,
    });
  } catch (err) {
    console.error("Signup error:", err);
    res.status(500).json({ message: "Server error" });
  }
};
// controller/event_controller.js
const Event = require("../model/event_model");
const RequestEvent = require("../model/request_model");

//$ ====== ADD New Request   ======
exports.addEventRequest = async (req, res, next) => {
  try {
    const userId = req.user._id || req.user.id;

    let {
      eventName,
      eventDescription,
      occasionType,
      eventDate,
      eventTime,
      price,
      invitationLink,
      maxAttendance,
      eventType,
      locationType,
      homeAddress,
      venue,
      services,
    } = req.body;

    // basic validation for location
    if (locationType === "home") {
      if (!homeAddress) {
        return res.status(400).json({
          success: false,
          message: "homeAddress is required when locationType is 'home'",
        });
      }
      // no venue needed
      venue = undefined;
    } else {
      // lounge/theatre
      if (!venue) {
        return res.status(400).json({
          success: false,
          message:
            "venue object is required when locationType is 'lounge' or 'theatre'",
        });
      }
    }

    // base event data
    const eventData = {
      organizerId: userId,
      eventName,
      eventDescription,
      occasionType,
      eventDate,
      eventTime,
      price,
      invitationLink,
      maxAttendance,
      eventType,
      locationType,
      homeAddress,
      venue, // embedded venue (or undefined if home)
      services,
    };

    // Create a request document instead of actual Event
    const request = await RequestEvent.create({
      requestType: "create",
      requestedBy: userId,
      eventId: null,
      event: eventData,
    });

    return res.status(201).json({
      success: true,
      message: "Event creation request submitted",
      data: request,
    });
  } catch (err) {
    next(err);
  }
};
//! ====== Edit My Request By ID  ======
exports.EditEventRequestById = async (req, res, next) => {
  try {
    const userId = req.user._id || req.user.id;
    const { eventId, event } = req.body;

    if (!eventId) {
      return res.status(400).json({
        success: false,
        message: "eventId is required for edit request",
      });
    }

    const existingEvent = await Event.findById(eventId);
    if (!existingEvent) {
      return res.status(404).json({
        success: false,
        message: "Event not found",
      });
    }

    if (!event) {
      return res.status(400).json({
        success: false,
        message: "Updated event data (event) is required",
      });
    }

    // Ensure organizerId stays the same owner (or use userId if you want)
    if (!event.organizerId) {
      event.organizerId = existingEvent.organizerId;
    }

    // Optional: basic location validation for edits
    if (event.locationType === "home") {
      if (!event.homeAddress) {
        return res.status(400).json({
          success: false,
          message:
            "homeAddress is required when locationType is 'home' for edit request",
        });
      }
      event.venue = undefined;
    } else if (
      event.locationType === "lounge" ||
      event.locationType === "theatre"
    ) {
      if (!event.venue) {
        return res.status(400).json({
          success: false,
          message:
            "venue object is required when locationType is 'lounge' or 'theatre' for edit request",
        });
      }
    }

    const request = await RequestEvent.create({
      requestType: "edit",
      requestedBy: userId,
      eventId,
      event,
    });

    return res.status(201).json({
      success: true,
      message: "Event edit request submitted",
      data: request,
    });
  } catch (err) {
    next(err);
  }
};
//$====== cancel My Request By ID  ======
exports.cancelEventRequestById = async (req, res, next) => {
  try {
    const userId = req.user._id || req.user.id;

    // requestId now comes from URL params
    const { requestId } = req.params;

    if (!requestId) {
      return res.status(400).json({
        success: false,
        message: "requestId is required to cancel a request",
      });
    }

    // Find the request that belongs to this user
    const request = await RequestEvent.findOne({
      _id: requestId,
      requestedBy: userId,
    });

    if (!request) {
      return res.status(404).json({
        success: false,
        message: "Request not found",
      });
    }

    if (request.status !== "pending") {
      return res.status(400).json({
        success: false,
        message: `Only pending requests can be cancelled (current status: ${request.status})`,
      });
    }

    await RequestEvent.findByIdAndDelete(requestId);

    return res.status(200).json({
      success: true,
      message: "Request cancelled successfully",
    });
  } catch (err) {
    next(err);
  }
};
//$ ====== Get My request Details By ID  ======
exports.getEventRequestDetails = async (req, res, next) => {
  try {
    const { id } = req.params;
    const userId = req.user._id || req.user.id;

    // Only allow user to see THEIR OWN requests
    const request = await RequestEvent.findOne({
      _id: id,
      requestedBy: userId,
    })
      .populate("requestedBy", "name email")
      .populate("eventId"); // for edit/cancel types

    if (!request) {
      return res.status(404).json({
        success: false,
        message: "Event request not found",
      });
    }

    return res.status(200).json({
      success: true,
      data: request,
    });
  } catch (err) {
    next(err);
  }
};
//$ ====== Get All My Requests (Requests Not Events )  ======
exports.getMyEventRequests = async (req, res, next) => {
  try {
    const userId = req.user._id || req.user.id;

    const requests = await RequestEvent.find({ requestedBy: userId }).sort({
      createdAt: -1,
    });

    return res.status(200).json({
      success: true,
      count: requests.length,
      data: requests,
    });
  } catch (err) {
    next(err);
  }
};
// controller/user_controller.js
const User = require("../model/user_model");
const Event = require("../model/event_model");

//$ ====== Me  ======
exports.me = async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select("-password");
    res.json({ message: "Authenticated", user });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};
//$ ====== Get all my Accepted Events  ======
exports.getMyEvents = async (req, res) => {
  try {
    const userId = req.user._id || req.user.id;

    const events = await Event.find({ organizerId: userId }).sort({
      eventDate: 1,
      eventTime: 1,
    });

    res.status(200).json({
      success: true,
      count: events.length,
      data: events,
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};


middlewares
// middlewares/middlewares.js
const jwt = require("jsonwebtoken");
const { JWT_SECRET } = require("../utils/jwt_helper");

function protect(req, res, next) {
  const auth = req.headers.authorization;
  if (!auth || !auth.startsWith("Bearer ")) {
    return res.status(401).json({ message: "No token provided" });
  }

  const token = auth.split(" ")[1];

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded;
    next();
  } catch (err) {
    return res.status(401).json({ message: "Invalid token" });
  }
}

function authorize(...roles) {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res
        .status(403)
        .json({ message: "Access denied You are not an Admin :3 " });
    }
    next();
  };
}

module.exports = { protect, authorize };

jwt helper
// jwt/jwt_helper.js
const jwt = require("jsonwebtoken");

const JWT_SECRET = "my_super_secret_key";

function createToken(user) {
  return jwt.sign(
    {
      id: user._id,
      email: user.email,
      role: user.role,
    },
    JWT_SECRET
    
  );
}

module.exports = { createToken, JWT_SECRET };

