Server 
const express = require("express");
const mongoose = require("mongoose");
const cors = require("cors");
// require("dotenv").config();
const authRoute = require("./routes/auth_routes");
const userRoute = require("./routes/user_routes");
const eventRoute = require("./routes/event_routes");
const adminRoute = require("./routes/admin_routes");
const servicesRoutes = require("./routes/services_routes");
const app = express();
const swaggerUi = require("swagger-ui-express");
const swaggerDocument = require("./swagger.json");

//! ====== keep only this, with the limit ======
app.use(express.json({ limit: "10mb" }));
app.use(express.urlencoded({ extended: true, limit: "10mb" }));

//! allow mobile device too while testing
app.use(cors({ origin: "*" }));

//! ====== MongoDB Connect ======
mongoose
  .connect("mongodb://127.0.0.1:27017/Event_mangment")
  .then(() => console.log("Mongo connected"))
  .catch((err) => console.error(err));

app.get("/", (req, res) => {
  res.send("API running");
});
//! ====== SwaggerUI ======
app.use("/api-docs", swaggerUi.serve, swaggerUi.setup(swaggerDocument));
app.get("/", (req, res) => {
  res.send("API running");
});
//? swagger_URL:  http://localhost:3000/api-docs/

//! ====== Routes ======
app.use("/api", userRoute);
app.use("/api/auth", authRoute);
app.use("/api/events", eventRoute);
app.use("/api/admin", adminRoute);
app.use("/api/services", servicesRoutes);
//! ====== Start server ======
app.listen(3000, () => {
  console.log("Server running on port 3000");
});


routes
// routes/admin_routes.js
const express = require("express");
const {
  getAllUsers,
  getAllEvents,
  getAllEventRequests,
  approveEventRequest,
  rejectEventRequest,
} = require("../controller/admin_controller");
const { protect, authorize } = require("../middlewares/middlewares"); // you add isAdmin

const adminRoute = express.Router();
//? ====== Only Admin is able to use this  ======
adminRoute.use(protect, authorize("admin"));
//$ ====== Get all Users ======
adminRoute.get("/users", getAllUsers);
//$ ====== Get ALl Accepted Events ======
adminRoute.get("/events", getAllEvents);
//$ ====== Get All Requests  ======
adminRoute.get("/requests", getAllEventRequests);
//$ ====== Approve an Request ======
adminRoute.patch("/requests/:id/approve", approveEventRequest);
//$ ====== Reject an Request ======
adminRoute.patch("/requests/:id/reject", rejectEventRequest);

module.exports = adminRoute;

const express = require("express");
const { login, signup } = require("../controller/auth_controller");
const authRoute = express.Router();

//$ ====== Login ======
authRoute.post("/login", login);
//$ ====== SignUp ======
authRoute.post("/signup", signup);

module.exports = authRoute;

// routes/event_routes.js
const express = require("express");
const {
  addEventRequest,
  EditEventRequestById,
  cancelEventRequestById,
  getEventRequestDetails,
  getMyEventRequests,
} = require("../controller/event_controller");
const { protect } = require("../middlewares/middlewares");

const eventRoute = express.Router();
//$ ====== Add new Request  ======
eventRoute.post("/", protect, addEventRequest);
//$ ====== cancel Request ======
eventRoute.delete("/:requestId", protect, cancelEventRequestById);
//! ====== Edit Request ======
eventRoute.patch("/", protect, EditEventRequestById);
//$ ====== Get all My Requests ======
eventRoute.get("/", protect, getMyEventRequests);
//$ ====== Get Request DetailsBy ID ======
eventRoute.get("/:id", protect, getEventRequestDetails);

module.exports = eventRoute;
// routes/meta_routes.js
const express = require("express");
const Venue = require("../model/venue_model");
const servicesConfig = require("../config/services_config");
const { protect } = require("../middlewares/middlewares");

const servicesRoute = express.Router();

// Get all active venues (optional filter by type)
servicesRoute.get("/locations", protect, async (req, res, next) => {
  try {
    const { type } = req.query; // ?type=lounge or ?type=theatre
    const query = { isActive: true };
    if (type) query.type = type;
    const venues = await Venue.find(query).sort({ name: 1 });

    res.status(200).json({
      success: true,
      data: venues,
    });
  } catch (err) {
    next(err);
  }
});

// Get all services configuration
servicesRoute.get("/", protect, (req, res) => {
  res.status(200).json({
    success: true,
    data: servicesConfig,
  });
});

module.exports = servicesRoute;

// routes/user_routes.js
const express = require("express");
const {
  me,
  getMyEvents,
} = require("../controller/user_controller");
const { protect, } = require("../middlewares/middlewares");

const userRoute = express.Router();
//$ ====== Get my details (Profile) ======
userRoute.get("/me", protect, me);
//$ ====== Get All My Events (accepted ones) ======
userRoute.get("/my-events", protect, getMyEvents);


module.exports = userRoute;

Models
// model/event_model.js
const mongoose = require("mongoose");

const VenueSchema = new mongoose.Schema(
  {
    image: { type: String, required: true },
    name: { type: String, required: true, trim: true },
    address: { type: String, required: true },
    cost: { type: Number, required: true },
    type: { type: String, enum: ["lounge", "theatre"], required: true },
  },
  { _id: false }
);

const EventSchema = new mongoose.Schema(
  {
    //! the User
    organizerId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },

    //! Event Name
    eventName: {
      type: String,
      required: true,
      trim: true,
    },

    eventDescription: { type: String, default: "" },

    occasionType: {
      type: String,
      enum: ["public", "private"],
      required: true,
    },

    //! DATE & TIME
    eventDate: { type: String, required: true },
    eventTime: { type: String, required: true },

    //! PRICE
    price: { type: Number, required: true },

    //! INVITATION LINK
    invitationLink: { type: String, default: "" },

    //! Max Attendance
    maxAttendance: { type: Number, required: true },

    //! Event Type
    eventType: {
      type: String,
      enum: [
        "wedding",
        "engagement",
        "graduation",
        "familyEvent",
        "photoSession",
        "musicalParty",
        "festival",
        "conference",
        "play",
        "custom",
      ],
      required: true,
    },

    //! LOCATION TYPE
    locationType: {
      type: String,
      enum: ["home", "lounge", "theatre"],
      required: true,
    },

    //! Used ONLY when locationType === "home"
    homeAddress: { type: String },

    //! Embedded venue data when NOT home
    venue: VenueSchema, // EMBEDDED â€” NO collection anymore

    //! SERVICES
    services: {
      hospitality: {
        enabled: { type: Boolean, default: false },
        cost: { type: Number, default: 0 },
        drinks: { type: Boolean, default: false },
        food: { type: Boolean, default: false },
        cake: { type: Boolean, default: false },
        icecream: { type: Boolean, default: false },
      },
      camera: {
        enabled: { type: Boolean, default: false },
        cost: { type: Number, default: 0 },
      },
      decoration: {
        enabled: { type: Boolean, default: false },
        cost: { type: Number, default: 0 },
      },
      limousine: {
        enabled: { type: Boolean, default: false },
        cost: { type: Number, default: 0 },
      },
      musicalBand: {
        enabled: { type: Boolean, default: false },
        cost: { type: Number, default: 0 },
      },
    },
  },
  { timestamps: true }
);

module.exports = mongoose.model("Event", EventSchema);

const mongoose = require("mongoose");
const Event = require("./event_model");

const RequestEventSchema = new mongoose.Schema(
  {
    requestType: {
      type: String,
      enum: ["create", "edit", "cancel"],
      required: true,
    },
    status: {
      type: String,
      enum: ["pending", "approved", "rejected"],
      default: "pending",
    },
    requestedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    eventId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Event",
    },
    event: {
      type: Event.schema,
      required: true,
    },
  },
  { timestamps: true, collection: "request_Events" }
);

module.exports = mongoose.model("RequestEvent", RequestEventSchema);
// model/user_model.js
const mongoose = require("mongoose");

const userSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    email: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
    },
    password: {
      type: String,
      required: true,
      minlength: 6,
    },
    role: {
      type: String,
      enum: ["user", "admin"],
      default: "user",
    },
    avatar: {
      type: String, 
      default: null, 
    },
  },
  { timestamps: true }
);

module.exports = mongoose.model("User", userSchema, "Users");
// model/venue_model.js
const mongoose = require("mongoose");

const venueSchema = new mongoose.Schema(
  {
    name: { type: String, required: true, trim: true },
    type: { type: String, enum: ["lounge", "theatre"], required: true },
    address: { type: String, required: true },
    image: { type: String, default: "" },
    baseCost: { type: Number, required: true },
    maxCapacity: { type: Number },
    isActive: { type: Boolean, default: true },
  },
  { timestamps: true }
);

module.exports = mongoose.model("Venue", venueSchema);

middlewares
// middlewares/middlewares.js
const jwt = require("jsonwebtoken");
const { JWT_SECRET } = require("../utils/jwt_helper");

function protect(req, res, next) {
  const auth = req.headers.authorization;
  if (!auth || !auth.startsWith("Bearer ")) {
    return res.status(401).json({ message: "No token provided" });
  }

  const token = auth.split(" ")[1];

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded;
    next();
  } catch (err) {
    return res.status(401).json({ message: "Invalid token" });
  }
}

function authorize(...roles) {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res
        .status(403)
        .json({ message: "Access denied You are not an Admin :3 " });
    }
    next();
  };
}

module.exports = { protect, authorize };

Controllers
const User = require("../model/user_model");
const Event = require("../model/event_model");
const RequestEvent = require("../model/request_model");

//$ ====== get ALl users (Admin) ======
exports.getAllUsers = async (req, res, next) => {
  try {
    const users = await User.find().select("-password"); // don't expose passwords
    return res.status(200).json({
      success: true,
      count: users.length,
      data: users,
    });
  } catch (err) {
    next(err);
  }
};
//$ ====== Get All Events (Admin) ======
exports.getAllEvents = async (req, res, next) => {
  try {
    const events = await Event.find().populate("organizerId", "name email");

    return res.status(200).json({
      success: true,
      count: events.length,
      data: events,
    });
  } catch (err) {
    next(err);
  }
};
//$ ====== Get All  Requests ======
exports.getAllEventRequests = async (req, res, next) => {
  try {
    const requests = await RequestEvent.find()
      .populate("requestedBy", "name email")
      .populate("eventId")
      .sort({ createdAt: -1 });

    return res.status(200).json({
      success: true,
      count: requests.length,
      data: requests,
    });
  } catch (err) {
    next(err);
  }
};
//$ ====== Approve Event By ID ======
exports.approveEventRequest = async (req, res, next) => {
  try {
    const { id } = req.params; // RequestEvent _id
    const request = await RequestEvent.findById(id);

    if (!request) {
      return res.status(404).json({
        success: false,
        message: "Request not found",
      });
    }

    if (request.status !== "pending") {
      return res.status(400).json({
        success: false,
        message: `Request already ${request.status}`,
      });
    }

    let resultEvent = null;

    // ---------- CREATE ----------
    if (request.requestType === "create") {
      // convert snapshot to plain new event
      let eventData = request.event.toObject
        ? request.event.toObject()
        : request.event;

      delete eventData._id;
      delete eventData.createdAt;
      delete eventData.updatedAt;

      resultEvent = await Event.create(eventData);

      // delete request after success
      await RequestEvent.findByIdAndDelete(id);
    }

    // ---------- EDIT ----------
    else if (request.requestType === "edit") {
      if (!request.eventId) {
        return res.status(400).json({
          success: false,
          message: "Edit request missing eventId",
        });
      }

      let updates = request.event.toObject
        ? request.event.toObject()
        : request.event;

      delete updates._id;
      delete updates.createdAt;
      delete updates.updatedAt;

      resultEvent = await Event.findByIdAndUpdate(request.eventId, updates, {
        new: true,
        runValidators: true,
      });

      if (!resultEvent) {
        return res.status(404).json({
          success: false,
          message: "Original event not found",
        });
      }

      // delete request after success
      await RequestEvent.findByIdAndDelete(id);
    }

    // ---------- CANCEL ----------
    else if (request.requestType === "cancel") {
      if (!request.eventId) {
        return res.status(400).json({
          success: false,
          message: "Cancel request missing eventId",
        });
      }

      await Event.findByIdAndDelete(request.eventId);

      // delete request after success
      await RequestEvent.findByIdAndDelete(id);
    }

    // ---------- UNKNOWN ----------
    else {
      return res.status(400).json({
        success: false,
        message: `Unknown requestType: ${request.requestType}`,
      });
    }

    return res.status(200).json({
      success: true,
      message: "Request approved and removed from queue",
      data: {
        event: resultEvent,
      },
    });
  } catch (err) {
    next(err);
  }
};
//$ ====== Reject Event By ID ======
exports.rejectEventRequest = async (req, res, next) => {
  try {
    const { id } = req.params;

    const request = await RequestEvent.findById(id);
    if (!request) {
      return res.status(404).json({
        success: false,
        message: "Request not found",
      });
    }

    if (request.status !== "pending") {
      return res.status(400).json({
        success: false,
        message: `Request already ${request.status}`,
      });
    }

    request.status = "rejected";
    await request.save();

    return res.status(200).json({
      success: true,
      message: "Request rejected successfully",
      data: request,
    });
  } catch (err) {
    next(err);
  }
};
// controller/auth_controller.js
const User = require("../model/user_model");
const bcrypt = require("bcryptjs");
const { createToken } = require("../utils/jwt_helper");

//$ ====== Login  ======
exports.login = async (req, res) => {
  try {
    const { email, password } = req.body;
//! 1) Find user in DB
    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "Invalid credentials" });
//! 2) Compare password
    const match = await bcrypt.compare(password, user.password);
    if (!match) return res.status(400).json({ message: "Invalid credentials" });
 //! 3) Create token
    const token = createToken(user);

    res.json({
      message: "Logged in",
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        role: user.role,
        avatar: user.avatar,
      },
      token,
    });
  } catch (err) {
    console.error("Login error:", err);
    res.status(500).json({ message: "Server error" });
  }
};
//$ ====== Signup  ======
exports.signup = async (req, res) => {
  try {
    const { name, email, password, role, avatar } = req.body;

    if (!name || !email || !password) {
      return res
        .status(400)
        .json({ message: "name, email, password are required" });
    }

    //@ 1) Check if email exists in DB
    const exists = await User.findOne({ email });
    if (exists) {
      return res.status(400).json({ message: "Email already exists" });
    }

    //@ 2) Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    //@ 3) Create user
    const user = await User.create({
      name,
      email,
      password: hashedPassword,
      role: role || "user",
      avatar: avatar || null,
    });

    //@ 4) Create token
    const token = createToken(user);

    res.status(201).json({
      message: "User created",
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        role: user.role,
        avatar: user.avatar,
      },
      token,
    });
  } catch (err) {
    console.error("Signup error:", err);
    res.status(500).json({ message: "Server error" });
  }
};
// controller/event_controller.js
const Event = require("../model/event_model");
const RequestEvent = require("../model/request_model");
const Venue = require("../model/venue_model");
const servicesConfig = require("../config/services_config");

//$ ====== ADD New Request   ======

exports.addEventRequest = async (req, res, next) => {
  try {
    const userId = req.user._id || req.user.id;
    let {
      eventName,
      eventDescription,
      occasionType,
      eventDate,
      eventTime,
      maxAttendance,
      eventType,
      locationType,
      homeAddress,
      venueId,   // <-- now we expect this
      services,
    } = req.body;

    let venueSnapshot = undefined;
    let totalPrice = 0;

    // ---- LOCATION VALIDATION + VENUE LOOKUP ----
    if (locationType === "home") {
      if (!homeAddress) {
        return res.status(400).json({
          success: false,
          message: "homeAddress is required when locationType is 'home'",
        });
      }
      // maybe home has some base cost? up to you
    } else {
      if (!venueId) {
        return res.status(400).json({
          success: false,
          message: "venueId is required when locationType is 'lounge' or 'theatre'",
        });
      }

      const venue = await Venue.findOne({ _id: venueId, isActive: true });
      if (!venue) {
        return res.status(404).json({
          success: false,
          message: "Venue not found or inactive",
        });
      }

      // snapshot of venue into the Event
      venueSnapshot = {
        name: venue.name,
        type: venue.type,
        address: venue.address,
        cost: venue.baseCost,
        image: venue.image,
      };

      totalPrice += venue.baseCost;
    }

    // ---- SERVICES PRICING ----
    const selectedServices = services || {};
    const servicesSnapshot = {
      hospitality: {
        enabled: false,
        cost: 0,
        drinks: false,
        food: false,
        cake: false,
        icecream: false,
      },
      camera: { enabled: false, cost: 0 },
      decoration: { enabled: false, cost: 0 },
      limousine: { enabled: false, cost: 0 },
      musicalBand: { enabled: false, cost: 0 },
    };

    // hospitality
    if (selectedServices.hospitality?.enabled) {
      const config = servicesConfig.hospitality;
      let cost = config.baseCost;

      if (selectedServices.hospitality.drinks) {
        cost += config.options.drinks.extraCost;
      }
      if (selectedServices.hospitality.food) {
        cost += config.options.food.extraCost;
      }
      if (selectedServices.hospitality.cake) {
        cost += config.options.cake.extraCost;
      }
      if (selectedServices.hospitality.icecream) {
        cost += config.options.icecream.extraCost;
      }

      servicesSnapshot.hospitality = {
        enabled: true,
        cost,
        drinks: !!selectedServices.hospitality.drinks,
        food: !!selectedServices.hospitality.food,
        cake: !!selectedServices.hospitality.cake,
        icecream: !!selectedServices.hospitality.icecream,
      };

      totalPrice += cost;
    }

    // camera
    if (selectedServices.camera?.enabled) {
      const config = servicesConfig.camera;
      servicesSnapshot.camera = {
        enabled: true,
        cost: config.baseCost,
      };
      totalPrice += config.baseCost;
    }

    // same pattern for decoration, limousine, musicalBand...

    // ---- base event data (now price is calculated here) ----
    const eventData = {
      organizerId: userId,
      eventName,
      eventDescription,
      occasionType,
      eventDate,
      eventTime,
      price: totalPrice,        // <--- now server-side
      invitationLink: "",       // or generate later
      maxAttendance,
      eventType,
      locationType,
      homeAddress,
      venue: venueSnapshot,
      services: servicesSnapshot,
    };

    const request = await RequestEvent.create({
      requestType: "create",
      requestedBy: userId,
      eventId: null,
      event: eventData,
    });

    return res.status(201).json({
      success: true,
      message: "Event creation request submitted",
      data: request,
    });
  } catch (err) {
    next(err);
  }
};

//! ====== Edit My Request By ID  ======
exports.EditEventRequestById = async (req, res, next) => {
  try {
    const userId = req.user._id || req.user.id;
    const { eventId, event } = req.body;

    if (!eventId) {
      return res.status(400).json({
        success: false,
        message: "eventId is required for edit request",
      });
    }

    const existingEvent = await Event.findById(eventId);
    if (!existingEvent) {
      return res.status(404).json({
        success: false,
        message: "Event not found",
      });
    }

    if (!event) {
      return res.status(400).json({
        success: false,
        message: "Updated event data (event) is required",
      });
    }

    // Ensure organizerId stays the same owner (or use userId if you want)
    if (!event.organizerId) {
      event.organizerId = existingEvent.organizerId;
    }

    // Optional: basic location validation for edits
    if (event.locationType === "home") {
      if (!event.homeAddress) {
        return res.status(400).json({
          success: false,
          message:
            "homeAddress is required when locationType is 'home' for edit request",
        });
      }
      event.venue = undefined;
    } else if (
      event.locationType === "lounge" ||
      event.locationType === "theatre"
    ) {
      if (!event.venue) {
        return res.status(400).json({
          success: false,
          message:
            "venue object is required when locationType is 'lounge' or 'theatre' for edit request",
        });
      }
    }

    const request = await RequestEvent.create({
      requestType: "edit",
      requestedBy: userId,
      eventId,
      event,
    });

    return res.status(201).json({
      success: true,
      message: "Event edit request submitted",
      data: request,
    });
  } catch (err) {
    next(err);
  }
};
//$====== cancel My Request By ID  ======
exports.cancelEventRequestById = async (req, res, next) => {
  try {
    const userId = req.user._id || req.user.id;

    // requestId now comes from URL params
    const { requestId } = req.params;

    if (!requestId) {
      return res.status(400).json({
        success: false,
        message: "requestId is required to cancel a request",
      });
    }

    // Find the request that belongs to this user
    const request = await RequestEvent.findOne({
      _id: requestId,
      requestedBy: userId,
    });

    if (!request) {
      return res.status(404).json({
        success: false,
        message: "Request not found",
      });
    }

    if (request.status !== "pending") {
      return res.status(400).json({
        success: false,
        message: `Only pending requests can be cancelled (current status: ${request.status})`,
      });
    }

    await RequestEvent.findByIdAndDelete(requestId);

    return res.status(200).json({
      success: true,
      message: "Request cancelled successfully",
    });
  } catch (err) {
    next(err);
  }
};
//$ ====== Get My request Details By ID  ======
exports.getEventRequestDetails = async (req, res, next) => {
  try {
    const { id } = req.params;
    const userId = req.user._id || req.user.id;

    // Only allow user to see THEIR OWN requests
    const request = await RequestEvent.findOne({
      _id: id,
      requestedBy: userId,
    })
      .populate("requestedBy", "name email")
      .populate("eventId"); // for edit/cancel types

    if (!request) {
      return res.status(404).json({
        success: false,
        message: "Event request not found",
      });
    }

    return res.status(200).json({
      success: true,
      data: request,
    });
  } catch (err) {
    next(err);
  }
};
//$ ====== Get All My Requests (Requests Not Events )  ======
exports.getMyEventRequests = async (req, res, next) => {
  try {
    const userId = req.user._id || req.user.id;

    const requests = await RequestEvent.find({ requestedBy: userId }).sort({
      createdAt: -1,
    });

    return res.status(200).json({
      success: true,
      count: requests.length,
      data: requests,
    });
  } catch (err) {
    next(err);
  }
};
// controller/user_controller.js
const User = require("../model/user_model");
const Event = require("../model/event_model");

//$ ====== Me  ======
exports.me = async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select("-password");
    res.json({ message: "Authenticated", user });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};
//$ ====== Get all my Accepted Events  ======
exports.getMyEvents = async (req, res) => {
  try {
    const userId = req.user._id || req.user.id;

    const events = await Event.find({ organizerId: userId }).sort({
      eventDate: 1,
      eventTime: 1,
    });

    res.status(200).json({
      success: true,
      count: events.length,
      data: events,
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

services_config
// config/services_config.js
module.exports = {
  hospitality: {
    key: "hospitality",
    displayName: "Hospitality",
    pricingType: "perEvent", // or "perGuest"
    baseCost: 200,
    options: {
      drinks: { label: "Drinks", extraCost: 50 },
      food: { label: "Food", extraCost: 100 },
      cake: { label: "Cake", extraCost: 80 },
      icecream: { label: "Ice Cream", extraCost: 40 },
    },
  },
  camera: {
    key: "camera",
    displayName: "Photography / Videography",
    pricingType: "perEvent",
    baseCost: 100,
  },
  decoration: {
    key: "decoration",
    displayName: "Decoration",
    pricingType: "perEvent",
    baseCost: 150,
  },
  limousine: {
    key: "limousine",
    displayName: "Limousine",
    pricingType: "perEvent",
    baseCost: 300,
  },
  musicalBand: {
    key: "musicalBand",
    displayName: "Musical Band",
    pricingType: "perEvent",
    baseCost: 400,
  },
};
